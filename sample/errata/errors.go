// Package errata is auto-generated by errata
// Errata Schema Version: 0.1
// Hash: ecc97b277b464f660bfd5deec56106b7
package errata

import (
	"crypto/sha1"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

type erratum struct {
	code       string
	message    string
	categories []string
	args       map[string]interface{}
	labels     map[string]string
	guide      string

	file string
	line int

	uuid    string
	wrapped error
}

// TODO: add documentation to all public methods

// Erratum is the public interface which indicates that a given error is an Erratum.
type Erratum interface {
	// behave like a regular error
	error
	Unwrap() error

	Code() string
	Message() string
	Categories() []string
	Args() map[string]interface{}
	Guide() string
	Labels() map[string]string

	UUID() string
	HelpURL() string
}

func (e *erratum) Unwrap() error {
	return e.wrapped
}

func (e *erratum) UUID() string {
	if e.uuid == "" {
		e.uuid = generateReference(e.code)
	}
	return e.uuid
}

// Format controls the verbosity of the printed error.
func (e *erratum) Format(f fmt.State, verb rune) {
	if verb == 'v' && f.Flag('+') {
		args := func() string {
			if len(e.Args()) <= 0 {
				return ""
			}

			var args []string
			for k, v := range e.Args() {
				args = append(args, fmt.Sprintf(`%s="%+v"`, k, v))
			}
			return fmt.Sprintf(` (%s)`, strings.Join(args, ", "))
		}()

		f.Write([]byte(fmt.Sprintf("%s%s For more details, see %s", e.Error(), args, e.HelpURL())))
		if unwrapped := e.Unwrap(); unwrapped != nil {
			if e, ok := unwrapped.(fmt.Formatter); ok {
				f.Write([]byte("\nâ†³ "))
				e.Format(f, verb)
			}
		}
	} else {
		f.Write([]byte(e.Error()))
	}
}

func (e *erratum) Error() string {
	return fmt.Sprintf("[%s] <%s:%v> %s", e.code, e.file, e.line, e.message)
}

func (e *erratum) HelpURL() string {
	return fmt.Sprintf("https://errata.codes/errata/sample/%s", e.code)
}

func (e *erratum) Code() string {
	return e.code
}

func (e *erratum) Message() string {
	return e.message
}

func (e *erratum) Categories() []string {
	return e.categories
}

func (e *erratum) Args() map[string]interface{} {
	return e.args
}

func (e *erratum) Labels() map[string]string {
	return e.labels
}

func (e *erratum) Guide() string {
	return e.guide
}

func (e *erratum) File() string {
	return e.file
}

func (e *erratum) Line() int {
	return e.line
}

const (
	AccountBlockedAbuseErrCode  string = "account-blocked-abuse"
	AccountBlockedSpamErrCode   string = "account-blocked-spam"
	IncorrectCredentialsErrCode string = "incorrect-credentials"
	InvalidEmailErrCode         string = "invalid-email"
	InvalidRequestErrCode       string = "invalid-request"
	MissingValuesErrCode        string = "missing-values"
	ResponseFormattingErrCode   string = "response-formatting"
)

type AccountBlockedAbuseErr struct {
	erratum
}
type AccountBlockedSpamErr struct {
	erratum
}
type IncorrectCredentialsErr struct {
	erratum
}
type InvalidEmailErr struct {
	erratum
}
type InvalidRequestErr struct {
	erratum
}
type MissingValuesErr struct {
	erratum
}
type ResponseFormattingErr struct {
	erratum
}

func NewAccountBlockedAbuseErr(wrapped error) *AccountBlockedAbuseErr {
	err := erratum{
		code:       AccountBlockedAbuseErrCode,
		message:    `Account is blocked because of abuse`,
		categories: []string{"login"},
		labels: map[string]string{
			"http_response_code": "403",
			"shell_exit_code":    "3",
		},
		guide: ``,

		args:    map[string]interface{}{},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &AccountBlockedAbuseErr{err}
}

// GetHttpResponseCode returns the "http_response_code" label for a AccountBlockedAbuseErr instance.
func (e *AccountBlockedAbuseErr) GetHttpResponseCode() string {
	return "403"
}

// GetShellExitCode returns the "shell_exit_code" label for a AccountBlockedAbuseErr instance.
func (e *AccountBlockedAbuseErr) GetShellExitCode() string {
	return "3"
}

func NewAccountBlockedSpamErr(wrapped error) *AccountBlockedSpamErr {
	err := erratum{
		code:       AccountBlockedSpamErrCode,
		message:    `Account is blocked because of spam`,
		categories: []string{"login"},
		labels: map[string]string{
			"http_response_code": "403",
			"shell_exit_code":    "3",
		},
		guide: ``,

		args:    map[string]interface{}{},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &AccountBlockedSpamErr{err}
}

// GetHttpResponseCode returns the "http_response_code" label for a AccountBlockedSpamErr instance.
func (e *AccountBlockedSpamErr) GetHttpResponseCode() string {
	return "403"
}

// GetShellExitCode returns the "shell_exit_code" label for a AccountBlockedSpamErr instance.
func (e *AccountBlockedSpamErr) GetShellExitCode() string {
	return "3"
}

func NewIncorrectCredentialsErr(wrapped error) *IncorrectCredentialsErr {
	err := erratum{
		code:       IncorrectCredentialsErrCode,
		message:    `Given credentials are incorrect`,
		categories: []string{"login"},
		labels: map[string]string{
			"http_response_code": "403",
			"shell_exit_code":    "2",
		},
		guide: ``,

		args:    map[string]interface{}{},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &IncorrectCredentialsErr{err}
}

// GetHttpResponseCode returns the "http_response_code" label for a IncorrectCredentialsErr instance.
func (e *IncorrectCredentialsErr) GetHttpResponseCode() string {
	return "403"
}

// GetShellExitCode returns the "shell_exit_code" label for a IncorrectCredentialsErr instance.
func (e *IncorrectCredentialsErr) GetShellExitCode() string {
	return "2"
}

func NewInvalidEmailErr(wrapped error, email string) *InvalidEmailErr {
	err := erratum{
		code:       InvalidEmailErrCode,
		message:    `Given email is invalid`,
		categories: []string{"login"},
		labels: map[string]string{
			"http_response_code": "400",
			"shell_exit_code":    "1",
		},
		guide: `Ensure the email address has a _username_, an ` + "`" + `@` + "`" + ` symbol, and a _domain_ name.`,

		args: map[string]interface{}{
			"email": email,
		},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &InvalidEmailErr{err}
}

// GetEmail returns the "email" argument for a InvalidEmailErr instance.
func (e *InvalidEmailErr) GetEmail() interface{} {
	return e.args["email"]
}

// GetHttpResponseCode returns the "http_response_code" label for a InvalidEmailErr instance.
func (e *InvalidEmailErr) GetHttpResponseCode() string {
	return "400"
}

// GetShellExitCode returns the "shell_exit_code" label for a InvalidEmailErr instance.
func (e *InvalidEmailErr) GetShellExitCode() string {
	return "1"
}

func NewInvalidRequestErr(wrapped error) *InvalidRequestErr {
	err := erratum{
		code:       InvalidRequestErrCode,
		message:    `One or more values are missing`,
		categories: []string{"login"},
		labels: map[string]string{
			"http_response_code": "400",
			"shell_exit_code":    "1",
		},
		guide: ``,

		args:    map[string]interface{}{},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &InvalidRequestErr{err}
}

// GetHttpResponseCode returns the "http_response_code" label for a InvalidRequestErr instance.
func (e *InvalidRequestErr) GetHttpResponseCode() string {
	return "400"
}

// GetShellExitCode returns the "shell_exit_code" label for a InvalidRequestErr instance.
func (e *InvalidRequestErr) GetShellExitCode() string {
	return "1"
}

func NewMissingValuesErr(wrapped error, missingField string) *MissingValuesErr {
	err := erratum{
		code:       MissingValuesErrCode,
		message:    `Field is missing from the request`,
		categories: []string{"login"},
		labels: map[string]string{
			"http_response_code": "400",
			"shell_exit_code":    "1",
		},
		guide: ``,

		args: map[string]interface{}{
			"missingField": missingField,
		},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &MissingValuesErr{err}
}

// GetMissingField returns the "missingField" argument for a MissingValuesErr instance.
func (e *MissingValuesErr) GetMissingField() interface{} {
	return e.args["missingField"]
}

// GetHttpResponseCode returns the "http_response_code" label for a MissingValuesErr instance.
func (e *MissingValuesErr) GetHttpResponseCode() string {
	return "400"
}

// GetShellExitCode returns the "shell_exit_code" label for a MissingValuesErr instance.
func (e *MissingValuesErr) GetShellExitCode() string {
	return "1"
}

func NewResponseFormattingErr(wrapped error) *ResponseFormattingErr {
	err := erratum{
		code:       ResponseFormattingErrCode,
		message:    `Failed to format response body`,
		categories: []string{"internal"},
		labels: map[string]string{
			"http_response_code": "500",
		},
		guide: ``,

		args:    map[string]interface{}{},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &ResponseFormattingErr{err}
}

// GetHttpResponseCode returns the "http_response_code" label for a ResponseFormattingErr instance.
func (e *ResponseFormattingErr) GetHttpResponseCode() string {
	return "500"
}
func addCaller(err *erratum) {
	_, file, line, ok := runtime.Caller(3)
	if ok {
		paths := strings.Split(file, string(os.PathSeparator))
		segments := 2
		if len(paths) < segments {
			segments = 1
		}
		err.file = filepath.Join(paths[len(paths)-segments:]...)
		err.line = line
	}
}

func generateReference(code string) string {
	return fmt.Sprintf("%x", sha1.Sum([]byte(code+time.Now().Format(time.RFC3339Nano))))
}
