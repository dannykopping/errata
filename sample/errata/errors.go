// Package errata is auto-generated by errata
// Errata Schema Version: 0.1
// Hash: c87437d6283730b71c43970b77d9e41e
package errata

import (
	"crypto/sha1"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

type erratum struct {
	code       string
	message    string
	categories []string
	args       map[string]interface{}
	labels     map[string]string
	guide      string

	file string
	line int

	uuid    string
	wrapped error
}

// TODO: add documentation to all public methods

// Erratum is the public interface which indicates that a given error is an Erratum.
type Erratum interface {
	// behave like a regular error
	error
	Unwrap() error

	Code() string
	Message() string
	Categories() []string
	Args() map[string]interface{}
	Guide() string
	Labels() map[string]string

	UUID() string
	HelpURL() string
}

func (e *erratum) Unwrap() error {
	return e.wrapped
}

func (e *erratum) UUID() string {
	if e.uuid == "" {
		e.uuid = generateReference(e.code)
	}
	return e.uuid
}

// Format controls the verbosity of the printed error.
func (e *erratum) Format(f fmt.State, verb rune) {
	if verb == 'v' && f.Flag('+') {
		args := func() string {
			if len(e.Args()) <= 0 {
				return ""
			}

			var args []string
			for k, v := range e.Args() {
				args = append(args, fmt.Sprintf(`%s="%+v"`, k, v))
			}
			return fmt.Sprintf(` (%s)`, strings.Join(args, ", "))
		}()

		f.Write([]byte(fmt.Sprintf("%s%s For more details, see %s", e.Error(), args, e.HelpURL())))
		if unwrapped := e.Unwrap(); unwrapped != nil {
			if e, ok := unwrapped.(fmt.Formatter); ok {
				f.Write([]byte("\nâ†³ "))
				e.Format(f, verb)
			}
		}
	} else {
		f.Write([]byte(e.Error()))
	}
}

func (e *erratum) Error() string {
	return fmt.Sprintf("[%s] <%s:%v> %s", e.code, e.file, e.line, e.message)
}

func (e *erratum) HelpURL() string {
	return fmt.Sprintf("https://errata.codes/errata/sample/%s", e.code)
}

func (e *erratum) Code() string {
	return e.code
}

func (e *erratum) Message() string {
	return e.message
}

func (e *erratum) Categories() []string {
	return e.categories
}

func (e *erratum) Args() map[string]interface{} {
	return e.args
}

func (e *erratum) Labels() map[string]string {
	return e.labels
}

func (e *erratum) Guide() string {
	return e.guide
}

func (e *erratum) File() string {
	return e.file
}

func (e *erratum) Line() int {
	return e.line
}

const (
	MissingCommandErrCode        string = "missing-command"
	ScriptExecutionFailedErrCode string = "script-execution-failed"
	ScriptNotFoundErrCode        string = "script-not-found"
)

type MissingCommandErr struct {
	erratum
}
type ScriptExecutionFailedErr struct {
	erratum
}
type ScriptNotFoundErr struct {
	erratum
}

func NewMissingCommandErr(wrapped error) *MissingCommandErr {
	err := erratum{
		code:       MissingCommandErrCode,
		message:    `Command was not specified`,
		categories: []string{"validation"},
		labels: map[string]string{
			"http_response_code": "400",
		},
		guide: ``,

		args:    map[string]interface{}{},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &MissingCommandErr{err}
}

// GetHttpResponseCode returns the "http_response_code" label for a MissingCommandErr instance.
func (e *MissingCommandErr) GetHttpResponseCode() string {
	return "400"
}

func NewScriptExecutionFailedErr(wrapped error) *ScriptExecutionFailedErr {
	err := erratum{
		code:       ScriptExecutionFailedErrCode,
		message:    `Given script returned an error`,
		categories: []string{"execution"},
		labels: map[string]string{
			"http_response_code": "500",
		},
		guide: ``,

		args:    map[string]interface{}{},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &ScriptExecutionFailedErr{err}
}

// GetHttpResponseCode returns the "http_response_code" label for a ScriptExecutionFailedErr instance.
func (e *ScriptExecutionFailedErr) GetHttpResponseCode() string {
	return "500"
}

func NewScriptNotFoundErr(wrapped error, path string) *ScriptNotFoundErr {
	err := erratum{
		code:       ScriptNotFoundErrCode,
		message:    `Given script was not found`,
		categories: []string{"validation"},
		labels: map[string]string{
			"http_response_code": "404",
		},
		guide: ``,

		args: map[string]interface{}{
			"path": path,
		},
		wrapped: wrapped,
	}

	addCaller(&err)
	return &ScriptNotFoundErr{err}
}

// GetPath returns the "path" argument for a ScriptNotFoundErr instance.
func (e *ScriptNotFoundErr) GetPath() interface{} {
	return e.args["path"]
}

// GetHttpResponseCode returns the "http_response_code" label for a ScriptNotFoundErr instance.
func (e *ScriptNotFoundErr) GetHttpResponseCode() string {
	return "404"
}
func addCaller(err *erratum) {
	_, file, line, ok := runtime.Caller(3)
	if ok {
		paths := strings.Split(file, string(os.PathSeparator))
		segments := 2
		if len(paths) < segments {
			segments = 1
		}
		err.file = filepath.Join(paths[len(paths)-segments:]...)
		err.line = line
	}
}

func generateReference(code string) string {
	return fmt.Sprintf("%x", sha1.Sum([]byte(code+time.Now().Format(time.RFC3339Nano))))
}
